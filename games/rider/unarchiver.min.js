"use strict";
const DIST = 1
  , EXT = DIST ? ".min.js" : ".js";
function loadScript(e, r) {
    return loadScriptFromPath(e + "lib/" + r + EXT)
}
function loadScriptFromPath(a) {
    return new Promise( (r, e) => {
        if ("object" == typeof window) {
            let e = document.createElement("script");
            e.type = "text/javascript",
            e.src = a,
            e.onload = r,
            document.head.appendChild(e)
        } else
            "function" == typeof importScripts ? (importScripts(a),
            r()) : e()
    }
    )
}
function currentScriptPath() {
    try {
        throw new Error("")
    } catch (e) {
        let r = e.stack
          , a = (-1 !== r.indexOf("@") ? r.split("@")[1].split("\n") : r.split("(")[1].split(")"))[0];
        return a.substring(0, a.lastIndexOf("/")) + "/"
    }
}
let unrarMemoryFileLocation = null
  , g_on_loaded_cb = null
  , unrarReady = new Promise( (e, r) => {
    g_on_loaded_cb = e
}
);
class Unarchiver {
    static async load(e=null) {
        return e = e || ["zip", "rar", "tar", "gz", "xz", "bz2"],
        Promise.all(e.map(this._loadFormat))
    }
    static async _loadFormat(t) {
        if (!(t in Unarchiver.loadedFormats)) {
            let a = currentScriptPath();
            return Unarchiver.loadedFormats[t] = new Promise(async (e, r) => {
                switch (t) {
                case "zip":
                    await loadScript(a, "jszip");
                    break;
                case "rar":
                    unrarMemoryFileLocation = a + "lib/libunrar.js.mem",
                    await loadScript(a, "libunrar"),
                    await unrarReady;
                    break;
                case "tar":
                    await loadScript(a, "libuntar");
                    break;
                case "gz":
                    await loadScript(a, "pako_inflate");
                    break;
                case "xz":
                    await loadScript(a, "xz");
                    break;
                case "bz2":
                    await loadScript(a, "bz2");
                    break;
                default:
                    throw new Error("Unknown archive format '" + t + "'.")
                }
                e()
            }
            )
        }
        await Unarchiver.loadedFormats[t]
    }
    static open(r, l=null) {
        let o = this;
        return new Promise( (i, e) => {
            let n = r.name;
            l = l || null;
            let s = new FileReader;
            s.onload = async () => {
                let e = s.result;
                o._isGzip(e) ? (await o._loadFormat("gz"),
                e = pako.inflate(e).buffer) : o._isXZ(e) ? (await o._loadFormat("xz"),
                e = toXZ(new Uint8Array(e), 0, 0, 0, 2 ** 28).buffer) : o._isBZ2(e) && (await o._loadFormat("bz2"),
                e = bz2.decompress(new Uint8Array(e)).buffer);
                let r = null
                  , a = []
                  , t = null;
                if (o._isRarFile(e))
                    t = "rar",
                    await o._loadFormat(t),
                    r = o._rarOpen(n, l, e),
                    a = o._rarGetEntries(r);
                else if (o._isZipFile(e))
                    t = "zip",
                    await o._loadFormat(t),
                    r = await o._zipOpen(n, l, e),
                    a = o._zipGetEntries(r);
                else {
                    if (!o._isTarFile(e))
                        throw new Error("The archive type is unknown");
                    t = "tar",
                    await o._loadFormat(t),
                    r = o._tarOpen(n, l, e),
                    a = o._tarGetEntries(r)
                }
                a.sort( (e, r) => e.name.localeCompare(r.name)),
                i({
                    file_name: n,
                    archive_type: t,
                    array_buffer: e,
                    entries: a,
                    handle: r
                })
            }
            ,
            s.readAsArrayBuffer(r)
        }
        )
    }
    static close(e) {
        e.file_name = null,
        e.archive_type = null,
        e.array_buffer = null,
        e.entries = null,
        e.handle = null
    }
    static _rarOpen(e, r, a) {
        return {
            file_name: e,
            array_buffer: a,
            password: r,
            rar_files: [{
                name: e,
                size: a.byteLength,
                type: "",
                content: new Uint8Array(a)
            }]
        }
    }
    static async _zipOpen(e, r, a) {
        return {
            file_name: e,
            array_buffer: a,
            password: r,
            zip: await JSZip.loadAsync(a)
        }
    }
    static _tarOpen(e, r, a) {
        return {
            file_name: e,
            array_buffer: a,
            password: r
        }
    }
    static _rarGetEntries(n) {
        return Object.entries(readRARFile(n.rar_files, n.password)).map( ([,e]) => {
            let t = e.name
              , i = e.is_file;
            return {
                name: t,
                is_file: e.is_file,
                size_compressed: e.size_compressed,
                size_uncompressed: e.size_uncompressed,
                read: () => new Promise( (r, a) => {
                    if (i)
                        try {
                            readRARContent(n.rar_files, n.password, t, e => {
                                r(new File([e],t))
                            }
                            )
                        } catch (e) {
                            a(e)
                        }
                    else
                        r(null)
                }
                )
            }
        }
        )
    }
    static _zipGetEntries(e) {
        return Object.entries(e.zip.files).map( ([,a]) => {
            let t = a.name
              , i = !a.dir;
            var e = a._data ? a._data.compressedSize : 0
              , r = a._data ? a._data.uncompressedSize : 0;
            return {
                name: t,
                is_file: i,
                size_compressed: e,
                size_uncompressed: r,
                read: () => new Promise(async (e, r) => {
                    e(i ? new File([await a.async("blob")],t) : null)
                }
                )
            }
        }
        )
    }
    static _tarGetEntries(s) {
        return tarGetEntries(s.file_name, s.array_buffer).map(t => {
            let i = t.name
              , n = t.is_file;
            var e = t.size;
            return {
                name: i,
                is_file: n,
                size_compressed: e,
                size_uncompressed: e,
                read: () => new Promise( (e, r) => {
                    var a;
                    n ? (a = tarGetEntryData(t, s.array_buffer),
                    e(new File([a.buffer],i))) : e(null)
                }
                )
            }
        }
        )
    }
    static _isRarFile(e) {
        if (e.byteLength < 8)
            return !1;
        e = new Uint8Array(e,0,8);
        return 82 == e[0] && (69 == e[1] && 126 == e[2] && 94 == e[3] || 97 == e[1] && 114 == e[2] && 33 == e[3] && 26 == e[4] && 7 == e[5] && (0 == e[6] || 1 == e[6] && 0 == e[7]))
    }
    static _isZipFile(e) {
        return this._checkHeader([80, 75, 3, 4], e)
    }
    static _isTarFile(e) {
        return this._checkHeader([117, 115, 116, 97, 114], e, 257, 512)
    }
    static _isGzip(e) {
        return this._checkHeader([31, 139, 8], e)
    }
    static _isBZ2(e) {
        return this._checkHeader([66, 90, 104], e)
    }
    static _isXZ(e) {
        return this._checkHeader([253, 55, 122, 88, 90, 0], e)
    }
    static _checkHeader(r, e, a=0, t=null) {
        var i = a + r.length;
        if (e.byteLength < (t || i))
            return !1;
        var n = new Uint8Array(e,a,i);
        for (let e = 0; e < r.length; ++e)
            if (n[e] != r[e])
                return !1;
        return !0
    }
}
Unarchiver.loadedFormats = {};
